2026-02-19 11:46:00.785473+01:00 database: opening D:/DEV/spring-boot-kafka-batch/data/batchdb (build 224)
2026-02-19 11:46:01.328043+01:00 database: opened D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:46:01.331044+01:00 database: connecting session #3 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:46:01.333041+01:00 jdbc[3]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:46:01.333041+01:00 jdbc[3]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:46:01.334038+01:00 jdbc[3]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:46:01.334038+01:00 jdbc[3]: 
/**/Connection conn1 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:46:01.339055+01:00 jdbc[3]: 
/*SQL #:1 t:3*/CALL READONLY();
2026-02-19 11:46:01.363957+01:00 jdbc[3]: 
/*SQL t:5*/CREATE TABLE IF NOT EXISTS batch_records ( id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, external_id VARCHAR(255), name VARCHAR(255) NOT NULL, \"value\" DECIMAL(20,4), category VARCHAR(100), event_ts TIMESTAMP, record_hash VARCHAR(64) NOT NULL, job_id VARCHAR(100), partition_idx INTEGER, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, status VARCHAR(20) DEFAULT 'LOADED', CONSTRAINT uq_record_hash UNIQUE (record_hash) );
2026-02-19 11:46:01.367198+01:00 jdbc[3]: 
/*SQL t:1*/CREATE INDEX IF NOT EXISTS idx_batch_records_job ON batch_records (job_id, partition_idx);
2026-02-19 11:46:01.368197+01:00 jdbc[3]: 
/*SQL */CREATE TABLE IF NOT EXISTS job_file_log ( file_id VARCHAR(255) PRIMARY KEY, status VARCHAR(20) NOT NULL DEFAULT 'PROCESSING', job_execution_id BIGINT, started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, completed_at TIMESTAMP, record_count BIGINT, error_message VARCHAR(2000) );
2026-02-19 11:46:01.379199+01:00 jdbc[3]: 
/*SQL */CREATE TABLE IF NOT EXISTS job_file_log ( file_id VARCHAR(255) PRIMARY KEY, status VARCHAR(20) NOT NULL DEFAULT 'PROCESSING', job_execution_id BIGINT, started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, completed_at TIMESTAMP, record_count BIGINT, error_message VARCHAR(2000) );
2026-02-19 11:46:01.380198+01:00 jdbc[3]: 
/*SQL */CREATE TABLE IF NOT EXISTS batch_records ( id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, external_id VARCHAR(255), name VARCHAR(255) NOT NULL, \"value\" DECIMAL(20,4), category VARCHAR(100), event_ts TIMESTAMP, record_hash VARCHAR(64) NOT NULL, job_id VARCHAR(100), partition_idx INTEGER, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, status VARCHAR(20) DEFAULT 'LOADED', CONSTRAINT uq_record_hash UNIQUE (record_hash) );
2026-02-19 11:46:01.381201+01:00 jdbc[3]: 
/*SQL */CREATE INDEX IF NOT EXISTS idx_batch_records_job ON batch_records (job_id, partition_idx);
2026-02-19 11:46:01.460572+01:00 database: connecting session #4 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:46:01.461569+01:00 jdbc[4]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:46:01.463574+01:00 jdbc[4]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:46:01.465573+01:00 jdbc[4]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:46:01.465573+01:00 jdbc[4]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:46:01.467574+01:00 jdbc[4]: 
/**/Connection conn2 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:46:01.467574+01:00 jdbc[4]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:46:01.492707+01:00 database: connecting session #5 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:46:01.495152+01:00 jdbc[5]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:46:01.495701+01:00 jdbc[5]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:46:01.495701+01:00 jdbc[5]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:46:01.496701+01:00 jdbc[5]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:46:01.496701+01:00 jdbc[5]: 
/**/Connection conn3 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:46:01.496701+01:00 jdbc[5]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:46:01.523406+01:00 database: connecting session #6 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:46:01.523406+01:00 jdbc[6]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:46:01.524405+01:00 jdbc[6]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:46:01.526404+01:00 jdbc[6]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:46:01.527272+01:00 jdbc[6]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:46:01.527802+01:00 jdbc[6]: 
/**/Connection conn4 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:46:01.527802+01:00 jdbc[6]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:46:01.551463+01:00 database: connecting session #7 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:46:01.552469+01:00 jdbc[7]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:46:01.552469+01:00 jdbc[7]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:46:01.553461+01:00 jdbc[7]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:46:01.553461+01:00 jdbc[7]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:46:01.554463+01:00 jdbc[7]: 
/**/Connection conn5 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:46:01.555463+01:00 jdbc[7]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:46:01.568138+01:00 database: connecting session #8 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:46:01.569142+01:00 jdbc[8]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:46:01.569142+01:00 jdbc[8]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:46:01.570138+01:00 jdbc[8]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:46:01.570138+01:00 jdbc[8]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:46:01.572139+01:00 jdbc[8]: 
/**/Connection conn6 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:46:01.574147+01:00 jdbc[8]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:46:01.598144+01:00 database: connecting session #9 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:46:01.598144+01:00 jdbc[9]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:46:01.599143+01:00 jdbc[9]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:46:01.599143+01:00 jdbc[9]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:46:01.600017+01:00 jdbc[9]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:46:01.600554+01:00 jdbc[9]: 
/**/Connection conn7 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:46:01.600554+01:00 jdbc[9]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:46:01.613943+01:00 database: connecting session #10 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:46:01.614431+01:00 jdbc[10]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:46:01.614948+01:00 jdbc[10]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:46:01.614948+01:00 jdbc[10]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:46:01.614948+01:00 jdbc[10]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:46:01.614948+01:00 jdbc[10]: 
/**/Connection conn8 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:46:01.615960+01:00 jdbc[10]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:46:01.629966+01:00 database: connecting session #11 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:46:01.630964+01:00 jdbc[11]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:46:01.630964+01:00 jdbc[11]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:46:01.630964+01:00 jdbc[11]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:46:01.631960+01:00 jdbc[11]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:46:01.631960+01:00 jdbc[11]: 
/**/Connection conn9 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:46:01.631960+01:00 jdbc[11]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:46:01.659601+01:00 database: connecting session #12 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:46:01.659601+01:00 jdbc[12]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:46:01.660603+01:00 jdbc[12]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:46:01.660603+01:00 jdbc[12]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:46:01.661600+01:00 jdbc[12]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:46:01.661600+01:00 jdbc[12]: 
/**/Connection conn10 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:46:01.661600+01:00 jdbc[12]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:46:02.624805+01:00 jdbc[3]: 
/*SQL #:1*/CALL DATABASE();
2026-02-19 11:46:09.571512+01:00 database: disconnecting session #3
2026-02-19 11:46:09.572530+01:00 database: disconnected session #3
2026-02-19 11:46:09.572530+01:00 database: disconnecting session #4
2026-02-19 11:46:09.573528+01:00 database: disconnected session #4
2026-02-19 11:46:09.573528+01:00 database: disconnecting session #5
2026-02-19 11:46:09.574530+01:00 database: disconnected session #5
2026-02-19 11:46:09.574530+01:00 database: disconnecting session #6
2026-02-19 11:46:09.574530+01:00 database: disconnected session #6
2026-02-19 11:46:09.574530+01:00 database: disconnecting session #7
2026-02-19 11:46:09.575528+01:00 database: disconnected session #7
2026-02-19 11:46:09.575528+01:00 database: disconnecting session #8
2026-02-19 11:46:09.576531+01:00 database: disconnected session #8
2026-02-19 11:46:09.576531+01:00 database: disconnecting session #9
2026-02-19 11:46:09.576531+01:00 database: disconnected session #9
2026-02-19 11:46:09.577527+01:00 database: disconnecting session #10
2026-02-19 11:46:09.577527+01:00 database: disconnected session #10
2026-02-19 11:46:09.577527+01:00 database: disconnecting session #11
2026-02-19 11:46:09.577527+01:00 database: disconnected session #11
2026-02-19 11:46:09.578525+01:00 database: disconnecting session #12
2026-02-19 11:46:09.666741+01:00 database: closing D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:46:09.673741+01:00 database: closed
2026-02-19 11:47:53.827108+01:00 database: opening D:/DEV/spring-boot-kafka-batch/data/batchdb (build 224)
2026-02-19 11:47:55.246553+01:00 database: opened D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:47:55.254553+01:00 database: connecting session #3 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:47:55.256552+01:00 jdbc[3]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:47:55.258555+01:00 jdbc[3]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:47:55.259557+01:00 jdbc[3]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:47:55.261558+01:00 jdbc[3]: 
/**/Connection conn1 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:47:55.265557+01:00 jdbc[3]: 
/*SQL #:1 t:2*/CALL READONLY();
2026-02-19 11:47:55.322673+01:00 jdbc[3]: 
/*SQL */CREATE TABLE IF NOT EXISTS batch_records ( id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, external_id VARCHAR(255), name VARCHAR(255) NOT NULL, \"value\" DECIMAL(20,4), category VARCHAR(100), event_ts TIMESTAMP, record_hash VARCHAR(64) NOT NULL, job_id VARCHAR(100), partition_idx INTEGER, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, status VARCHAR(20) DEFAULT 'LOADED', CONSTRAINT uq_record_hash UNIQUE (record_hash) );
2026-02-19 11:47:55.323674+01:00 jdbc[3]: 
/*SQL */CREATE INDEX IF NOT EXISTS idx_batch_records_job ON batch_records (job_id, partition_idx);
2026-02-19 11:47:55.325675+01:00 jdbc[3]: 
/*SQL */CREATE TABLE IF NOT EXISTS job_file_log ( file_id VARCHAR(255) PRIMARY KEY, status VARCHAR(20) NOT NULL DEFAULT 'PROCESSING', job_execution_id BIGINT, started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, completed_at TIMESTAMP, record_count BIGINT, error_message VARCHAR(2000) );
2026-02-19 11:47:55.353674+01:00 jdbc[3]: 
/*SQL */CREATE TABLE IF NOT EXISTS job_file_log ( file_id VARCHAR(255) PRIMARY KEY, status VARCHAR(20) NOT NULL DEFAULT 'PROCESSING', job_execution_id BIGINT, started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, completed_at TIMESTAMP, record_count BIGINT, error_message VARCHAR(2000) );
2026-02-19 11:47:55.377778+01:00 jdbc[3]: 
/*SQL */CREATE TABLE IF NOT EXISTS batch_records ( id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, external_id VARCHAR(255), name VARCHAR(255) NOT NULL, \"value\" DECIMAL(20,4), category VARCHAR(100), event_ts TIMESTAMP, record_hash VARCHAR(64) NOT NULL, job_id VARCHAR(100), partition_idx INTEGER, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, status VARCHAR(20) DEFAULT 'LOADED', CONSTRAINT uq_record_hash UNIQUE (record_hash) );
2026-02-19 11:47:55.378780+01:00 jdbc[3]: 
/*SQL */CREATE INDEX IF NOT EXISTS idx_batch_records_job ON batch_records (job_id, partition_idx);
2026-02-19 11:47:55.748191+01:00 database: connecting session #4 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:47:55.750209+01:00 jdbc[4]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:47:55.750209+01:00 jdbc[4]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:47:55.751209+01:00 jdbc[4]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:47:55.751209+01:00 jdbc[4]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:47:55.751209+01:00 jdbc[4]: 
/**/Connection conn2 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:47:55.754211+01:00 jdbc[4]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:47:55.892213+01:00 database: connecting session #5 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:47:55.898156+01:00 jdbc[5]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:47:55.899157+01:00 jdbc[5]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:47:55.899157+01:00 jdbc[5]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:47:55.900157+01:00 jdbc[5]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:47:55.900157+01:00 jdbc[5]: 
/**/Connection conn3 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:47:55.901151+01:00 jdbc[5]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:47:56.007833+01:00 database: connecting session #6 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:47:56.008836+01:00 jdbc[6]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:47:56.009838+01:00 jdbc[6]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:47:56.010832+01:00 jdbc[6]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:47:56.010832+01:00 jdbc[6]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:47:56.011839+01:00 jdbc[6]: 
/**/Connection conn4 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:47:56.011839+01:00 jdbc[6]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:47:56.037853+01:00 database: connecting session #7 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:47:56.038836+01:00 jdbc[7]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:47:56.039838+01:00 jdbc[7]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:47:56.039838+01:00 jdbc[7]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:47:56.040838+01:00 jdbc[7]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:47:56.041835+01:00 jdbc[7]: 
/**/Connection conn5 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:47:56.042836+01:00 jdbc[7]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:47:56.073837+01:00 database: connecting session #8 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:47:56.073837+01:00 jdbc[8]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:47:56.074838+01:00 jdbc[8]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:47:56.075837+01:00 jdbc[8]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:47:56.075837+01:00 jdbc[8]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:47:56.076834+01:00 jdbc[8]: 
/**/Connection conn6 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:47:56.078837+01:00 jdbc[8]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:47:56.280837+01:00 database: connecting session #9 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:47:56.284834+01:00 jdbc[9]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:47:56.284834+01:00 jdbc[9]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:47:56.291850+01:00 jdbc[9]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:47:56.293834+01:00 jdbc[9]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:47:56.294830+01:00 jdbc[9]: 
/**/Connection conn7 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:47:56.294830+01:00 jdbc[9]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:47:56.310328+01:00 database: connecting session #10 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:47:56.311333+01:00 jdbc[10]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:47:56.311333+01:00 jdbc[10]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:47:56.312332+01:00 jdbc[10]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:47:56.312332+01:00 jdbc[10]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:47:56.313334+01:00 jdbc[10]: 
/**/Connection conn8 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:47:56.313334+01:00 jdbc[10]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:47:56.331328+01:00 database: connecting session #11 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:47:56.331328+01:00 jdbc[11]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:47:56.332326+01:00 jdbc[11]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:47:56.332326+01:00 jdbc[11]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:47:56.333328+01:00 jdbc[11]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:47:56.333328+01:00 jdbc[11]: 
/**/Connection conn9 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:47:56.333328+01:00 jdbc[11]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:47:56.475227+01:00 database: connecting session #12 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:47:56.482199+01:00 jdbc[12]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:47:56.483200+01:00 jdbc[12]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:47:56.484199+01:00 jdbc[12]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:47:56.485199+01:00 jdbc[12]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:47:56.485199+01:00 jdbc[12]: 
/**/Connection conn10 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:47:56.485199+01:00 jdbc[12]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:48:02.379702+01:00 jdbc[3]: 
/*SQL #:1*/CALL DATABASE();
2026-02-19 11:49:36.364234+01:00 jdbc[3]: 
/*SQL l:76 #:1 t:12*/SELECT COUNT(*) FROM job_file_log WHERE file_id = ? AND status = 'COMPLETED' {1: 'file-20260218-001'};
2026-02-19 11:49:36.535987+01:00 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Table "BATCH_JOB_INSTANCE" not found; SQL statement:
SELECT JOB_INSTANCE_ID, JOB_NAME
FROM BATCH_JOB_INSTANCE
WHERE JOB_NAME = ?
 and JOB_KEY = ? [42102-224]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:514)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:489)
	at org.h2.message.DbException.get(DbException.java:223)
	at org.h2.message.DbException.get(DbException.java:199)
	at org.h2.command.Parser.getTableOrViewNotFoundDbException(Parser.java:8064)
	at org.h2.command.Parser.getTableOrViewNotFoundDbException(Parser.java:8035)
	at org.h2.command.Parser.readTableOrView(Parser.java:8024)
	at org.h2.command.Parser.readTablePrimary(Parser.java:1788)
	at org.h2.command.Parser.readTableReference(Parser.java:2268)
	at org.h2.command.Parser.parseSelectFromPart(Parser.java:2718)
	at org.h2.command.Parser.parseSelect(Parser.java:2824)
	at org.h2.command.Parser.parseQueryPrimary(Parser.java:2708)
	at org.h2.command.Parser.parseQueryTerm(Parser.java:2564)
	at org.h2.command.Parser.parseQueryExpressionBody(Parser.java:2543)
	at org.h2.command.Parser.parseQueryExpressionBodyAndEndOfQuery(Parser.java:2536)
	at org.h2.command.Parser.parseQueryExpression(Parser.java:2529)
	at org.h2.command.Parser.parseQuery(Parser.java:2498)
	at org.h2.command.Parser.parsePrepared(Parser.java:627)
	at org.h2.command.Parser.parse(Parser.java:592)
	at org.h2.command.Parser.parse(Parser.java:564)
	at org.h2.command.Parser.prepareCommand(Parser.java:483)
	at org.h2.engine.SessionLocal.prepareLocal(SessionLocal.java:639)
	at org.h2.engine.SessionLocal.prepareCommand(SessionLocal.java:559)
	at org.h2.jdbc.JdbcConnection.prepareCommand(JdbcConnection.java:1166)
	at org.h2.jdbc.JdbcPreparedStatement.<init>(JdbcPreparedStatement.java:93)
	at org.h2.jdbc.JdbcConnection.prepareStatement(JdbcConnection.java:316)
	at com.zaxxer.hikari.pool.ProxyConnection.prepareStatement(ProxyConnection.java:327)
	at com.zaxxer.hikari.pool.HikariProxyConnection.prepareStatement(HikariProxyConnection.java)
	at org.springframework.jdbc.core.JdbcTemplate$SimplePreparedStatementCreator.createPreparedStatement(JdbcTemplate.java:1712)
	at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:656)
	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:723)
	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:754)
	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:767)
	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:825)
	at org.springframework.batch.core.repository.dao.JdbcJobInstanceDao.getJobInstance(JdbcJobInstanceDao.java:183)
	at org.springframework.batch.core.repository.support.SimpleJobRepository.getLastJobExecution(SimpleJobRepository.java:299)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:352)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:196)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)
	at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:123)
	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:385)
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:249)
	at jdk.proxy2/jdk.proxy2.$Proxy130.getLastJobExecution(Unknown Source)
	at org.springframework.batch.core.launch.support.SimpleJobLauncher.run(SimpleJobLauncher.java:111)
	at org.springframework.batch.core.launch.support.TaskExecutorJobLauncher.run(TaskExecutorJobLauncher.java:59)
	at com.ing.kallitech.kafka.batch.service.KafkaMessageListener.lambda$handleFileMessage$0(KafkaMessageListener.java:107)
	at java.base/java.util.Optional.map(Optional.java:260)
	at com.ing.kallitech.kafka.batch.service.KafkaMessageListener.handleFileMessage(KafkaMessageListener.java:105)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
	at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:56)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:375)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:92)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:53)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2857)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2835)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$56(KafkaMessageListenerContainer.java:2753)
	at io.micrometer.observation.Observation.observe(Observation.java:565)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2751)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2604)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2490)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2132)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1487)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1451)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1322)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.lang.Thread.run(Thread.java:842)
2026-02-19 11:49:36.648321+01:00 jdbc[3]: 
/*SQL */ROLLBACK;
2026-02-19 11:49:36.648321+01:00 jdbc[3]: 
/*SQL */COMMIT;
2026-02-19 11:49:37.031312+01:00 jdbc[3]: 
/*SQL l:104*/UPDATE job_file_log SET status='FAILED', completed_at=CURRENT_TIMESTAMP, error_message=? WHERE file_id=? {1: U&'org.springframework.jdbc.BadSqlGrammarException: PreparedStatementCallback; bad SQL grammar [SELECT JOB_INSTANCE_ID, JOB_NAME\\000aFROM BATCH_JOB_INSTANCE\\000aWHERE JOB_NAME = ?\\000a and JOB_KEY = ?]', 2: 'file-20260218-001'};
2026-02-19 11:49:37.035724+01:00 jdbc[3]: 
/*SQL */COMMIT;
2026-02-19 11:49:37.036722+01:00 jdbc[3]: 
/*SQL */COMMIT;
2026-02-19 11:51:09.218725+01:00 database: opening D:/DEV/spring-boot-kafka-batch/data/batchdb (build 224)
2026-02-19 11:51:14.045946+01:00 database: opened D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:51:14.049940+01:00 database: connecting session #3 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:51:14.049940+01:00 jdbc[3]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:51:14.050939+01:00 jdbc[3]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:51:14.053936+01:00 jdbc[3]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:51:14.054939+01:00 jdbc[3]: 
/**/Connection conn1 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:51:14.058937+01:00 jdbc[3]: 
/*SQL #:1 t:2*/CALL READONLY();
2026-02-19 11:51:14.115635+01:00 jdbc[3]: 
/*SQL */CREATE TABLE IF NOT EXISTS batch_records ( id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, external_id VARCHAR(255), name VARCHAR(255) NOT NULL, \"value\" DECIMAL(20,4), category VARCHAR(100), event_ts TIMESTAMP, record_hash VARCHAR(64) NOT NULL, job_id VARCHAR(100), partition_idx INTEGER, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, status VARCHAR(20) DEFAULT 'LOADED', CONSTRAINT uq_record_hash UNIQUE (record_hash) );
2026-02-19 11:51:14.115635+01:00 jdbc[3]: 
/*SQL */CREATE INDEX IF NOT EXISTS idx_batch_records_job ON batch_records (job_id, partition_idx);
2026-02-19 11:51:14.117635+01:00 jdbc[3]: 
/*SQL */CREATE TABLE IF NOT EXISTS job_file_log ( file_id VARCHAR(255) PRIMARY KEY, status VARCHAR(20) NOT NULL DEFAULT 'PROCESSING', job_execution_id BIGINT, started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, completed_at TIMESTAMP, record_count BIGINT, error_message VARCHAR(2000) );
2026-02-19 11:51:14.215788+01:00 jdbc[3]: 
/*SQL */CREATE TABLE IF NOT EXISTS job_file_log ( file_id VARCHAR(255) PRIMARY KEY, status VARCHAR(20) NOT NULL DEFAULT 'PROCESSING', job_execution_id BIGINT, started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, completed_at TIMESTAMP, record_count BIGINT, error_message VARCHAR(2000) );
2026-02-19 11:51:14.216785+01:00 jdbc[3]: 
/*SQL */CREATE TABLE IF NOT EXISTS batch_records ( id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, external_id VARCHAR(255), name VARCHAR(255) NOT NULL, \"value\" DECIMAL(20,4), category VARCHAR(100), event_ts TIMESTAMP, record_hash VARCHAR(64) NOT NULL, job_id VARCHAR(100), partition_idx INTEGER, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, status VARCHAR(20) DEFAULT 'LOADED', CONSTRAINT uq_record_hash UNIQUE (record_hash) );
2026-02-19 11:51:14.220781+01:00 jdbc[3]: 
/*SQL */CREATE INDEX IF NOT EXISTS idx_batch_records_job ON batch_records (job_id, partition_idx);
2026-02-19 11:51:14.377043+01:00 database: connecting session #4 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:51:14.378043+01:00 jdbc[4]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:51:14.378043+01:00 jdbc[4]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:51:14.378043+01:00 jdbc[4]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:51:14.379043+01:00 jdbc[4]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:51:14.379043+01:00 jdbc[4]: 
/**/Connection conn2 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:51:14.380043+01:00 jdbc[4]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:51:14.437520+01:00 database: connecting session #5 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:51:14.439525+01:00 jdbc[5]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:51:14.440518+01:00 jdbc[5]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:51:14.440518+01:00 jdbc[5]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:51:14.441557+01:00 jdbc[5]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:51:14.442068+01:00 jdbc[5]: 
/**/Connection conn3 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:51:14.442068+01:00 jdbc[5]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:51:14.522088+01:00 database: connecting session #6 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:51:14.523105+01:00 jdbc[6]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:51:14.525116+01:00 jdbc[6]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:51:14.526118+01:00 jdbc[6]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:51:14.528122+01:00 jdbc[6]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:51:14.529120+01:00 jdbc[6]: 
/**/Connection conn4 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:51:14.530118+01:00 jdbc[6]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:51:14.612522+01:00 database: connecting session #7 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:51:14.613520+01:00 jdbc[7]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:51:14.614520+01:00 jdbc[7]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:51:14.614520+01:00 jdbc[7]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:51:14.615520+01:00 jdbc[7]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:51:14.616519+01:00 jdbc[7]: 
/**/Connection conn5 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:51:14.616519+01:00 jdbc[7]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:51:14.684524+01:00 database: connecting session #8 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:51:14.684524+01:00 jdbc[8]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:51:14.689526+01:00 jdbc[8]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:51:14.690525+01:00 jdbc[8]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:51:14.690525+01:00 jdbc[8]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:51:14.691525+01:00 jdbc[8]: 
/**/Connection conn6 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:51:14.691525+01:00 jdbc[8]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:51:14.731525+01:00 database: connecting session #9 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:51:14.732526+01:00 jdbc[9]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:51:14.732526+01:00 jdbc[9]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:51:14.733525+01:00 jdbc[9]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:51:14.737524+01:00 jdbc[9]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:51:14.745379+01:00 jdbc[9]: 
/**/Connection conn7 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:51:14.746393+01:00 jdbc[9]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:51:14.795619+01:00 database: connecting session #10 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:51:14.796622+01:00 jdbc[10]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:51:14.797620+01:00 jdbc[10]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:51:14.797620+01:00 jdbc[10]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:51:14.797620+01:00 jdbc[10]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:51:14.798620+01:00 jdbc[10]: 
/**/Connection conn8 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:51:14.800623+01:00 jdbc[10]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:51:14.858764+01:00 database: connecting session #11 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:51:14.859759+01:00 jdbc[11]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:51:14.860758+01:00 jdbc[11]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:51:14.860758+01:00 jdbc[11]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:51:14.861759+01:00 jdbc[11]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:51:14.861759+01:00 jdbc[11]: 
/**/Connection conn9 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:51:14.861759+01:00 jdbc[11]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:51:14.917624+01:00 database: connecting session #12 to D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 11:51:14.921624+01:00 jdbc[12]: 
/*SQL */SET DB_CLOSE_DELAY -1;
2026-02-19 11:51:14.922629+01:00 jdbc[12]: 
/*SQL */SET MODE Oracle;
2026-02-19 11:51:14.923628+01:00 jdbc[12]: 
/*SQL */SET AUTO_SERVER TRUE;
2026-02-19 11:51:14.923628+01:00 jdbc[12]: 
/*SQL */SET TRACE_LEVEL_FILE 2;
2026-02-19 11:51:14.924625+01:00 jdbc[12]: 
/**/Connection conn10 = DriverManager.getConnection("jdbc:h2:file:./data/batchdb;DB_CLOSE_DELAY=-1;MODE=Oracle;AUTO_SERVER=TRUE;TRACE_LEVEL_FILE=2", "SA", "");
2026-02-19 11:51:14.929633+01:00 jdbc[12]: 
/*SQL #:1*/CALL READONLY();
2026-02-19 11:51:18.922255+01:00 jdbc[3]: 
/*SQL #:1*/CALL DATABASE();
2026-02-19 11:59:36.832466+01:00 jdbc[3]: 
/*SQL l:76 #:1 t:12*/SELECT COUNT(*) FROM job_file_log WHERE file_id = ? AND status = 'COMPLETED' {1: 'file-20260218-001'};
2026-02-19 11:59:36.912463+01:00 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Table "BATCH_JOB_INSTANCE" not found; SQL statement:
SELECT JOB_INSTANCE_ID, JOB_NAME
FROM BATCH_JOB_INSTANCE
WHERE JOB_NAME = ?
 and JOB_KEY = ? [42102-224]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:514)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:489)
	at org.h2.message.DbException.get(DbException.java:223)
	at org.h2.message.DbException.get(DbException.java:199)
	at org.h2.command.Parser.getTableOrViewNotFoundDbException(Parser.java:8064)
	at org.h2.command.Parser.getTableOrViewNotFoundDbException(Parser.java:8035)
	at org.h2.command.Parser.readTableOrView(Parser.java:8024)
	at org.h2.command.Parser.readTablePrimary(Parser.java:1788)
	at org.h2.command.Parser.readTableReference(Parser.java:2268)
	at org.h2.command.Parser.parseSelectFromPart(Parser.java:2718)
	at org.h2.command.Parser.parseSelect(Parser.java:2824)
	at org.h2.command.Parser.parseQueryPrimary(Parser.java:2708)
	at org.h2.command.Parser.parseQueryTerm(Parser.java:2564)
	at org.h2.command.Parser.parseQueryExpressionBody(Parser.java:2543)
	at org.h2.command.Parser.parseQueryExpressionBodyAndEndOfQuery(Parser.java:2536)
	at org.h2.command.Parser.parseQueryExpression(Parser.java:2529)
	at org.h2.command.Parser.parseQuery(Parser.java:2498)
	at org.h2.command.Parser.parsePrepared(Parser.java:627)
	at org.h2.command.Parser.parse(Parser.java:592)
	at org.h2.command.Parser.parse(Parser.java:564)
	at org.h2.command.Parser.prepareCommand(Parser.java:483)
	at org.h2.engine.SessionLocal.prepareLocal(SessionLocal.java:639)
	at org.h2.engine.SessionLocal.prepareCommand(SessionLocal.java:559)
	at org.h2.jdbc.JdbcConnection.prepareCommand(JdbcConnection.java:1166)
	at org.h2.jdbc.JdbcPreparedStatement.<init>(JdbcPreparedStatement.java:93)
	at org.h2.jdbc.JdbcConnection.prepareStatement(JdbcConnection.java:316)
	at com.zaxxer.hikari.pool.ProxyConnection.prepareStatement(ProxyConnection.java:327)
	at com.zaxxer.hikari.pool.HikariProxyConnection.prepareStatement(HikariProxyConnection.java)
	at org.springframework.jdbc.core.JdbcTemplate$SimplePreparedStatementCreator.createPreparedStatement(JdbcTemplate.java:1712)
	at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:656)
	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:723)
	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:754)
	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:767)
	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:825)
	at org.springframework.batch.core.repository.dao.JdbcJobInstanceDao.getJobInstance(JdbcJobInstanceDao.java:183)
	at org.springframework.batch.core.repository.support.SimpleJobRepository.getLastJobExecution(SimpleJobRepository.java:299)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:352)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:196)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)
	at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:123)
	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:385)
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:249)
	at jdk.proxy2/jdk.proxy2.$Proxy130.getLastJobExecution(Unknown Source)
	at org.springframework.batch.core.launch.support.SimpleJobLauncher.run(SimpleJobLauncher.java:111)
	at org.springframework.batch.core.launch.support.TaskExecutorJobLauncher.run(TaskExecutorJobLauncher.java:59)
	at com.ing.kallitech.kafka.batch.service.KafkaMessageListener.lambda$handleFileMessage$0(KafkaMessageListener.java:107)
	at java.base/java.util.Optional.map(Optional.java:260)
	at com.ing.kallitech.kafka.batch.service.KafkaMessageListener.handleFileMessage(KafkaMessageListener.java:105)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
	at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:56)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:375)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:92)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:53)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2857)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2835)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$56(KafkaMessageListenerContainer.java:2753)
	at io.micrometer.observation.Observation.observe(Observation.java:565)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2751)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2604)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2490)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2132)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1487)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1451)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1322)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.lang.Thread.run(Thread.java:842)
2026-02-19 11:59:36.933465+01:00 jdbc[3]: 
/*SQL */ROLLBACK;
2026-02-19 11:59:36.934466+01:00 jdbc[3]: 
/*SQL */COMMIT;
2026-02-19 11:59:37.168472+01:00 jdbc[3]: 
/*SQL l:104*/UPDATE job_file_log SET status='FAILED', completed_at=CURRENT_TIMESTAMP, error_message=? WHERE file_id=? {1: U&'org.springframework.jdbc.BadSqlGrammarException: PreparedStatementCallback; bad SQL grammar [SELECT JOB_INSTANCE_ID, JOB_NAME\\000aFROM BATCH_JOB_INSTANCE\\000aWHERE JOB_NAME = ?\\000a and JOB_KEY = ?]', 2: 'file-20260218-001'};
2026-02-19 11:59:37.172470+01:00 jdbc[3]: 
/*SQL */COMMIT;
2026-02-19 11:59:37.173477+01:00 jdbc[3]: 
/*SQL */COMMIT;
2026-02-19 11:59:42.587502+01:00 jdbc[3]: 
/*SQL l:76 #:1*/SELECT COUNT(*) FROM job_file_log WHERE file_id = ? AND status = 'COMPLETED' {1: 'file-20260218-001'};
2026-02-19 11:59:42.591499+01:00 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Table "BATCH_JOB_INSTANCE" not found; SQL statement:
SELECT JOB_INSTANCE_ID, JOB_NAME
FROM BATCH_JOB_INSTANCE
WHERE JOB_NAME = ?
 and JOB_KEY = ? [42102-224]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:514)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:489)
	at org.h2.message.DbException.get(DbException.java:223)
	at org.h2.message.DbException.get(DbException.java:199)
	at org.h2.command.Parser.getTableOrViewNotFoundDbException(Parser.java:8064)
	at org.h2.command.Parser.getTableOrViewNotFoundDbException(Parser.java:8035)
	at org.h2.command.Parser.readTableOrView(Parser.java:8024)
	at org.h2.command.Parser.readTablePrimary(Parser.java:1788)
	at org.h2.command.Parser.readTableReference(Parser.java:2268)
	at org.h2.command.Parser.parseSelectFromPart(Parser.java:2718)
	at org.h2.command.Parser.parseSelect(Parser.java:2824)
	at org.h2.command.Parser.parseQueryPrimary(Parser.java:2708)
	at org.h2.command.Parser.parseQueryTerm(Parser.java:2564)
	at org.h2.command.Parser.parseQueryExpressionBody(Parser.java:2543)
	at org.h2.command.Parser.parseQueryExpressionBodyAndEndOfQuery(Parser.java:2536)
	at org.h2.command.Parser.parseQueryExpression(Parser.java:2529)
	at org.h2.command.Parser.parseQuery(Parser.java:2498)
	at org.h2.command.Parser.parsePrepared(Parser.java:627)
	at org.h2.command.Parser.parse(Parser.java:592)
	at org.h2.command.Parser.parse(Parser.java:564)
	at org.h2.command.Parser.prepareCommand(Parser.java:483)
	at org.h2.engine.SessionLocal.prepareLocal(SessionLocal.java:639)
	at org.h2.engine.SessionLocal.prepareCommand(SessionLocal.java:559)
	at org.h2.jdbc.JdbcConnection.prepareCommand(JdbcConnection.java:1166)
	at org.h2.jdbc.JdbcPreparedStatement.<init>(JdbcPreparedStatement.java:93)
	at org.h2.jdbc.JdbcConnection.prepareStatement(JdbcConnection.java:316)
	at com.zaxxer.hikari.pool.ProxyConnection.prepareStatement(ProxyConnection.java:327)
	at com.zaxxer.hikari.pool.HikariProxyConnection.prepareStatement(HikariProxyConnection.java)
	at org.springframework.jdbc.core.JdbcTemplate$SimplePreparedStatementCreator.createPreparedStatement(JdbcTemplate.java:1712)
	at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:656)
	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:723)
	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:754)
	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:767)
	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:825)
	at org.springframework.batch.core.repository.dao.JdbcJobInstanceDao.getJobInstance(JdbcJobInstanceDao.java:183)
	at org.springframework.batch.core.repository.support.SimpleJobRepository.getLastJobExecution(SimpleJobRepository.java:299)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:352)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:196)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)
	at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:123)
	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:385)
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:249)
	at jdk.proxy2/jdk.proxy2.$Proxy130.getLastJobExecution(Unknown Source)
	at org.springframework.batch.core.launch.support.SimpleJobLauncher.run(SimpleJobLauncher.java:111)
	at org.springframework.batch.core.launch.support.TaskExecutorJobLauncher.run(TaskExecutorJobLauncher.java:59)
	at com.ing.kallitech.kafka.batch.service.KafkaMessageListener.lambda$handleFileMessage$0(KafkaMessageListener.java:107)
	at java.base/java.util.Optional.map(Optional.java:260)
	at com.ing.kallitech.kafka.batch.service.KafkaMessageListener.handleFileMessage(KafkaMessageListener.java:105)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
	at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:56)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:375)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:92)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:53)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2857)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2835)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$56(KafkaMessageListenerContainer.java:2753)
	at io.micrometer.observation.Observation.observe(Observation.java:565)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2751)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2604)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2490)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2132)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1487)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1451)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1322)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.lang.Thread.run(Thread.java:842)
2026-02-19 11:59:42.606500+01:00 jdbc[3]: 
/*SQL */ROLLBACK;
2026-02-19 11:59:42.607499+01:00 jdbc[3]: 
/*SQL */COMMIT;
2026-02-19 11:59:42.767664+01:00 jdbc[3]: 
/*SQL l:104*/UPDATE job_file_log SET status='FAILED', completed_at=CURRENT_TIMESTAMP, error_message=? WHERE file_id=? {1: U&'org.springframework.jdbc.BadSqlGrammarException: PreparedStatementCallback; bad SQL grammar [SELECT JOB_INSTANCE_ID, JOB_NAME\\000aFROM BATCH_JOB_INSTANCE\\000aWHERE JOB_NAME = ?\\000a and JOB_KEY = ?]', 2: 'file-20260218-001'};
2026-02-19 11:59:42.768660+01:00 jdbc[3]: 
/*SQL */COMMIT;
2026-02-19 11:59:42.769661+01:00 jdbc[3]: 
/*SQL */COMMIT;
2026-02-19 12:00:11.662536+01:00 jdbc[3]: 
/*SQL l:76 #:1*/SELECT COUNT(*) FROM job_file_log WHERE file_id = ? AND status = 'COMPLETED' {1: 'file-20260218-001'};
2026-02-19 12:00:11.665537+01:00 jdbc[3]: exception
org.h2.jdbc.JdbcSQLSyntaxErrorException: Table "BATCH_JOB_INSTANCE" not found; SQL statement:
SELECT JOB_INSTANCE_ID, JOB_NAME
FROM BATCH_JOB_INSTANCE
WHERE JOB_NAME = ?
 and JOB_KEY = ? [42102-224]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:514)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:489)
	at org.h2.message.DbException.get(DbException.java:223)
	at org.h2.message.DbException.get(DbException.java:199)
	at org.h2.command.Parser.getTableOrViewNotFoundDbException(Parser.java:8064)
	at org.h2.command.Parser.getTableOrViewNotFoundDbException(Parser.java:8035)
	at org.h2.command.Parser.readTableOrView(Parser.java:8024)
	at org.h2.command.Parser.readTablePrimary(Parser.java:1788)
	at org.h2.command.Parser.readTableReference(Parser.java:2268)
	at org.h2.command.Parser.parseSelectFromPart(Parser.java:2718)
	at org.h2.command.Parser.parseSelect(Parser.java:2824)
	at org.h2.command.Parser.parseQueryPrimary(Parser.java:2708)
	at org.h2.command.Parser.parseQueryTerm(Parser.java:2564)
	at org.h2.command.Parser.parseQueryExpressionBody(Parser.java:2543)
	at org.h2.command.Parser.parseQueryExpressionBodyAndEndOfQuery(Parser.java:2536)
	at org.h2.command.Parser.parseQueryExpression(Parser.java:2529)
	at org.h2.command.Parser.parseQuery(Parser.java:2498)
	at org.h2.command.Parser.parsePrepared(Parser.java:627)
	at org.h2.command.Parser.parse(Parser.java:592)
	at org.h2.command.Parser.parse(Parser.java:564)
	at org.h2.command.Parser.prepareCommand(Parser.java:483)
	at org.h2.engine.SessionLocal.prepareLocal(SessionLocal.java:639)
	at org.h2.engine.SessionLocal.prepareCommand(SessionLocal.java:559)
	at org.h2.jdbc.JdbcConnection.prepareCommand(JdbcConnection.java:1166)
	at org.h2.jdbc.JdbcPreparedStatement.<init>(JdbcPreparedStatement.java:93)
	at org.h2.jdbc.JdbcConnection.prepareStatement(JdbcConnection.java:316)
	at com.zaxxer.hikari.pool.ProxyConnection.prepareStatement(ProxyConnection.java:327)
	at com.zaxxer.hikari.pool.HikariProxyConnection.prepareStatement(HikariProxyConnection.java)
	at org.springframework.jdbc.core.JdbcTemplate$SimplePreparedStatementCreator.createPreparedStatement(JdbcTemplate.java:1712)
	at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:656)
	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:723)
	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:754)
	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:767)
	at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:825)
	at org.springframework.batch.core.repository.dao.JdbcJobInstanceDao.getJobInstance(JdbcJobInstanceDao.java:183)
	at org.springframework.batch.core.repository.support.SimpleJobRepository.getLastJobExecution(SimpleJobRepository.java:299)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:352)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:196)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)
	at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:123)
	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:385)
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:249)
	at jdk.proxy2/jdk.proxy2.$Proxy130.getLastJobExecution(Unknown Source)
	at org.springframework.batch.core.launch.support.SimpleJobLauncher.run(SimpleJobLauncher.java:111)
	at org.springframework.batch.core.launch.support.TaskExecutorJobLauncher.run(TaskExecutorJobLauncher.java:59)
	at com.ing.kallitech.kafka.batch.service.KafkaMessageListener.lambda$handleFileMessage$0(KafkaMessageListener.java:107)
	at java.base/java.util.Optional.map(Optional.java:260)
	at com.ing.kallitech.kafka.batch.service.KafkaMessageListener.handleFileMessage(KafkaMessageListener.java:105)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
	at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:56)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:375)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:92)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:53)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2857)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2835)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$56(KafkaMessageListenerContainer.java:2753)
	at io.micrometer.observation.Observation.observe(Observation.java:565)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2751)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2604)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2490)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2132)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1487)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1451)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1322)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.lang.Thread.run(Thread.java:842)
2026-02-19 12:00:11.670074+01:00 jdbc[3]: 
/*SQL */ROLLBACK;
2026-02-19 12:00:11.671073+01:00 jdbc[3]: 
/*SQL */COMMIT;
2026-02-19 12:00:11.830695+01:00 jdbc[3]: 
/*SQL l:104*/UPDATE job_file_log SET status='FAILED', completed_at=CURRENT_TIMESTAMP, error_message=? WHERE file_id=? {1: U&'org.springframework.jdbc.BadSqlGrammarException: PreparedStatementCallback; bad SQL grammar [SELECT JOB_INSTANCE_ID, JOB_NAME\\000aFROM BATCH_JOB_INSTANCE\\000aWHERE JOB_NAME = ?\\000a and JOB_KEY = ?]', 2: 'file-20260218-001'};
2026-02-19 12:00:11.856369+01:00 jdbc[3]: 
/*SQL */COMMIT;
2026-02-19 12:00:11.861386+01:00 jdbc[3]: 
/*SQL t:2*/COMMIT;
2026-02-19 12:02:55.603764+01:00 database: closing D:/DEV/spring-boot-kafka-batch/data/batchdb from shutdown hook
2026-02-19 12:02:55.618400+01:00 database: disconnecting session #3
2026-02-19 12:02:55.618400+01:00 database: disconnected session #3
2026-02-19 12:02:55.619402+01:00 database: disconnecting session #4
2026-02-19 12:02:55.619402+01:00 database: disconnected session #4
2026-02-19 12:02:55.620401+01:00 database: disconnecting session #5
2026-02-19 12:02:55.620401+01:00 database: disconnected session #5
2026-02-19 12:02:55.620401+01:00 database: disconnecting session #6
2026-02-19 12:02:55.621401+01:00 database: disconnected session #6
2026-02-19 12:02:55.621401+01:00 database: disconnecting session #7
2026-02-19 12:02:55.621401+01:00 database: disconnected session #7
2026-02-19 12:02:55.625404+01:00 database: disconnecting session #8
2026-02-19 12:02:55.626403+01:00 database: disconnected session #8
2026-02-19 12:02:55.627409+01:00 database: disconnecting session #9
2026-02-19 12:02:55.627409+01:00 database: disconnected session #9
2026-02-19 12:02:55.628400+01:00 database: disconnecting session #10
2026-02-19 12:02:55.628400+01:00 database: disconnected session #10
2026-02-19 12:02:55.628400+01:00 database: disconnecting session #11
2026-02-19 12:02:55.628400+01:00 database: disconnected session #11
2026-02-19 12:02:55.629404+01:00 database: disconnecting session #12
2026-02-19 12:02:55.629404+01:00 database: closing D:/DEV/spring-boot-kafka-batch/data/batchdb
2026-02-19 12:02:55.858747+01:00 database: closed
